#[doc = ""]
#[allow(dead_code, non_camel_case_types, clippy::upper_case_acronyms)]
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Rule {
    EOI,
    #[doc = "Regular rule."]
    r#Regular,
    #[doc = "Atomic rule."]
    r#Atomic,
    #[doc = "Silent rule."]
    r#Silent,
    #[doc = "Compound atomic rule."]
    r#CompoundAtomic,
    #[doc = "Tagged rule."]
    r#Tag,
    #[doc = "Non-atomic rule."]
    r#NonAtomic,
    r#ExactString,
    r#CaseInsensitive,
    r#CharRange,
    r#Any,
    r#Seq,
    r#Choice,
    r#Rep,
    r#RepAtLeastOnce,
    r#Opt,
    r#RepExact,
    r#RepLeft,
    r#RepRight,
    r#RepLeftRight,
    r#Pos,
    r#Neg,
    r#Push,
    r#Pop,
    r#PopAll,
    r#Peek,
    r#PeekLeft,
    r#PeekRight,
    r#PeekLeftRight,
    r#Drop,
    r#PeekAll,
}
#[doc(hidden)]
mod unicode {}
#[doc(hidden)]
mod constant_wrappers {
    #[doc = "A wrapper for `\"+\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_0();
    impl ::pest_typed::StringWrapper for r#w_0 {
        const CONTENT: &'static ::core::primitive::str = "+";
    }
    #[doc = "A wrapper for `\"(\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_1();
    impl ::pest_typed::StringWrapper for r#w_1 {
        const CONTENT: &'static ::core::primitive::str = "(";
    }
    #[doc = "A wrapper for `\")\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_2();
    impl ::pest_typed::StringWrapper for r#w_2 {
        const CONTENT: &'static ::core::primitive::str = ")";
    }
    #[doc = "A wrapper for `\"\\\"\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_3();
    impl ::pest_typed::StringWrapper for r#w_3 {
        const CONTENT: &'static ::core::primitive::str = "\"";
    }
    #[doc = "A wrapper for `\"\\\"\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_4();
    impl ::pest_typed::StringWrapper for r#w_4 {
        const CONTENT: &'static ::core::primitive::str = "\"";
    }
    #[doc = "A wrapper for `\"\\\"\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_5();
    impl ::pest_typed::StringWrapper for r#w_5 {
        const CONTENT: &'static ::core::primitive::str = "\"";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_6();
    impl ::pest_typed::StringWrapper for r#w_6 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"BB\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_7();
    impl ::pest_typed::StringWrapper for r#w_7 {
        const CONTENT: &'static ::core::primitive::str = "BB";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_8();
    impl ::pest_typed::StringWrapper for r#w_8 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"c\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_9();
    impl ::pest_typed::StringWrapper for r#w_9 {
        const CONTENT: &'static ::core::primitive::str = "c";
    }
    #[doc = "A wrapper for `\"r#\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_10();
    impl ::pest_typed::StringWrapper for r#w_10 {
        const CONTENT: &'static ::core::primitive::str = "r#";
    }
    #[doc = "A wrapper for `\"0x\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_11();
    impl ::pest_typed::StringWrapper for r#w_11 {
        const CONTENT: &'static ::core::primitive::str = "0x";
    }
    #[doc = "A wrapper for `\"1\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_12();
    impl ::pest_typed::StringWrapper for r#w_12 {
        const CONTENT: &'static ::core::primitive::str = "1";
    }
    #[doc = "A wrapper for `\".\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_13();
    impl ::pest_typed::StringWrapper for r#w_13 {
        const CONTENT: &'static ::core::primitive::str = ".";
    }
    #[doc = "A wrapper for `\"a\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_14();
    impl ::pest_typed::StringWrapper for r#w_14 {
        const CONTENT: &'static ::core::primitive::str = "a";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_15();
    impl ::pest_typed::StringWrapper for r#w_15 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"c\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_16();
    impl ::pest_typed::StringWrapper for r#w_16 {
        const CONTENT: &'static ::core::primitive::str = "c";
    }
    #[doc = "A wrapper for `\"b\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_17();
    impl ::pest_typed::StringWrapper for r#w_17 {
        const CONTENT: &'static ::core::primitive::str = "b";
    }
    #[doc = "A wrapper for `\"?\"`."]
    #[allow(non_camel_case_types)]
    #[derive(Clone, PartialEq)]
    pub struct r#w_18();
    impl ::pest_typed::StringWrapper for r#w_18 {
        const CONTENT: &'static ::core::primitive::str = "?";
    }
}
mod tags {
    pub mod r#Tag {
        #[doc = "Tag Second referenced by Tag."]
        ::pest_typed::tag!(r#Second, super::super::Rule, super::super::generics::Seq_3::<'i, super::super::generics::Push::<'i, super::super::rules::r#CompoundAtomic::<'i, INHERITED>>, super::super::generics::Positive::<'i, super::super::rules::r#Silent::<'i, INHERITED>>, super::super::generics::Negative::<'i, super::super::rules::r#Atomic::<'i, INHERITED>>, INHERITED>);
        impl<'i, const INHERITED: usize> r#Second<'i, INHERITED> {
            #[doc = "A helper function to access [`CompoundAtomic`]."]
            #[allow(non_snake_case)]
            pub fn r#CompoundAtomic<'s>(&'s self) -> &'s super::super::rules::r#CompoundAtomic<'i, INHERITED> {
                let res = &self.content;
                {
                    let res = &res.content.0.matched;
                    {
                        let res = &res.content;
                        res
                    }
                }
            }
            #[doc = "A helper function to access [`Silent`]."]
            #[allow(non_snake_case)]
            pub fn r#Silent<'s>(&'s self) -> &'s super::super::rules::r#Silent<'i, INHERITED> {
                let res = &self.content;
                {
                    let res = &res.content.1.matched;
                    {
                        let res = &res.content;
                        res
                    }
                }
            }
        }
        #[doc = "Tag Third referenced by Tag."]
        ::pest_typed::tag!(r#Third, super::super::Rule, super::super::generics::Rep::<'i, INHERITED, super::super::rules::r#NonAtomic::<'i, INHERITED>>);
        impl<'i, const INHERITED: usize> r#Third<'i, INHERITED> {
            #[doc = "A helper function to access [`NonAtomic`]."]
            #[allow(non_snake_case)]
            pub fn r#NonAtomic<'s>(&'s self) -> ::pest_typed::re_exported::Vec<&'s super::super::rules::r#NonAtomic<'i, INHERITED>> {
                let res = &self.content;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.1;
                            res
                        })
                        .collect::<::pest_typed::re_exported::Vec<_>>();
                    res
                }
            }
        }
    }
}
#[doc = "Definitions of statically typed nodes generated by pest-generator."]
pub mod rules {
    :: pest_typed :: rule ! (r#Regular , "Corresponds to expression: `(CharRange+ ~ \"+\" ~ CharRange+)`." "Normal rule." "" "Regular rule." , super :: Rule , super :: Rule :: r#Regular , super :: generics :: Seq_3 :: < 'i , super :: generics :: RepOnce :: < 'i , INHERITED , super :: rules :: r#CharRange :: < 'i , INHERITED > > , super :: generics :: Str :: < super :: constant_wrappers :: r#w_0 > , super :: generics :: RepOnce :: < 'i , INHERITED , super :: rules :: r#CharRange :: < 'i , INHERITED > > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Regular<'i, INHERITED> {
        #[doc = "A helper function to access [`CharRange`]."]
        #[allow(non_snake_case)]
        pub fn r#CharRange<'s>(&'s self) -> (::pest_typed::re_exported::Vec<&'s super::rules::r#CharRange<'i, INHERITED>>, ::pest_typed::re_exported::Vec<&'s super::rules::r#CharRange<'i, INHERITED>>) {
            let res = &self.content;
            {
                let res = (
                    {
                        let res = &res.content.0.matched;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| {
                                    let res = &res.1;
                                    res
                                })
                                .collect::<::pest_typed::re_exported::Vec<_>>();
                            res
                        }
                    },
                    {
                        let res = &res.content.2.matched;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| {
                                    let res = &res.1;
                                    res
                                })
                                .collect::<::pest_typed::re_exported::Vec<_>>();
                            res
                        }
                    },
                );
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#Atomic , "Corresponds to expression: `('0'..'9')+`." "Atomic rule." "" "Atomic rule." , super :: Rule , super :: Rule :: r#Atomic , super :: generics :: RepOnce :: < 'i , 0 , super :: generics :: CharRange :: < '0' , '9' > > , super :: generics :: Skipped :: < 'i > , true , Span);
    impl<'i, const INHERITED: usize> r#Atomic<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Silent , "Corresponds to expression: `(\"(\" | \")\")`." "Normal rule." "" "Silent rule." , super :: Rule , super :: Rule :: r#Silent , super :: generics :: Choice_2 :: < super :: generics :: Str :: < super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < super :: constant_wrappers :: r#w_2 > , > , super :: generics :: Skipped :: < 'i > , INHERITED , Expression);
    impl<'i, const INHERITED: usize> r#Silent<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#CompoundAtomic , "Corresponds to expression: `(\"\\\"\" ~ (!\"\\\"\" ~ ANY)* ~ \"\\\"\")`." "Atomic rule." "" "Compound atomic rule." , super :: Rule , super :: Rule :: r#CompoundAtomic , super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < super :: constant_wrappers :: r#w_3 > , super :: generics :: Rep :: < 'i , 0 , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: generics :: Str :: < super :: constant_wrappers :: r#w_4 > > , super :: rules :: r#ANY , 0 > > , super :: generics :: Str :: < super :: constant_wrappers :: r#w_5 > , 0 > , super :: generics :: Skipped :: < 'i > , true , Both);
    impl<'i, const INHERITED: usize> r#CompoundAtomic<'i, INHERITED> {
        #[doc = "A helper function to access [`ANY`]."]
        #[allow(non_snake_case)]
        pub fn r#ANY<'s>(&'s self) -> ::pest_typed::re_exported::Vec<&'s super::rules::r#ANY> {
            let res = &self.content;
            {
                let res = &res.content.1.matched;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.1;
                            {
                                let res = &res.content.1.matched;
                                res
                            }
                        })
                        .collect::<::pest_typed::re_exported::Vec<_>>();
                    res
                }
            }
        }
    }
    :: pest_typed :: rule ! (r#Tag , "Corresponds to expression: `(ANY ~ (#Second = (PUSH(CompoundAtomic) ~ &Silent ~ !Atomic))? ~ ((#Third = NonAtomic*) ~ Regular+)?)`." "Normal rule." "" "Tagged rule." , super :: Rule , super :: Rule :: r#Tag , super :: generics :: Seq_3 :: < 'i , super :: rules :: r#ANY , :: pest_typed :: re_exported :: Option :: < super :: tags :: r#Tag :: r#Second :: < 'i , INHERITED > > , :: pest_typed :: re_exported :: Option :: < super :: generics :: Seq_2 :: < 'i , super :: tags :: r#Tag :: r#Third :: < 'i , INHERITED > , super :: generics :: RepOnce :: < 'i , INHERITED , super :: rules :: r#Regular :: < 'i , INHERITED > > , INHERITED > > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Tag<'i, INHERITED> {
        #[doc = "A helper function to access [`ANY`]."]
        #[allow(non_snake_case)]
        pub fn r#ANY<'s>(&'s self) -> &'s super::rules::r#ANY {
            let res = &self.content;
            {
                let res = &res.content.0.matched;
                res
            }
        }
        #[doc = "A helper function to access [`Regular`]."]
        #[allow(non_snake_case)]
        pub fn r#Regular<'s>(&'s self) -> ::pest_typed::re_exported::Option<::pest_typed::re_exported::Vec<&'s super::rules::r#Regular<'i, INHERITED>>> {
            let res = &self.content;
            {
                let res = &res.content.2.matched;
                {
                    let res = res.as_ref().and_then(|res| {
                        Some({
                            let res = &res.content.1.matched;
                            {
                                let res = res
                                    .content
                                    .iter()
                                    .map(|res| {
                                        let res = &res.1;
                                        res
                                    })
                                    .collect::<::pest_typed::re_exported::Vec<_>>();
                                res
                            }
                        })
                    });
                    res
                }
            }
        }
        #[doc = "A helper function to access [`Second`]."]
        #[allow(non_snake_case)]
        pub fn r#Second<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::tags::r#Tag::r#Second<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = &res.content.1.matched;
                {
                    let res = res.as_ref().and_then(|res| Some(res));
                    res
                }
            }
        }
        #[doc = "A helper function to access [`Third`]."]
        #[allow(non_snake_case)]
        pub fn r#Third<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::tags::r#Tag::r#Third<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = &res.content.2.matched;
                {
                    let res = res.as_ref().and_then(|res| {
                        Some({
                            let res = &res.content.0.matched;
                            res
                        })
                    });
                    res
                }
            }
        }
    }
    :: pest_typed :: rule ! (r#NonAtomic , "Corresponds to expression: `((CaseInsensitive? ~ CharRange+ ~ Tag*)? ~ (\"b\" | (\"BB\" ~ \"b\"?))? ~ ^\"c\"* ~ (!Seq ~ Any)+)`." "Non-atomic rule." "" "Non-atomic rule." , super :: Rule , super :: Rule :: r#NonAtomic , super :: generics :: Seq_4 :: < 'i , :: pest_typed :: re_exported :: Option :: < super :: generics :: Seq_3 :: < 'i , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#CaseInsensitive :: < 'i , 1 > > , super :: generics :: RepOnce :: < 'i , 1 , super :: rules :: r#CharRange :: < 'i , 1 > > , super :: generics :: Rep :: < 'i , 1 , super :: rules :: r#Tag :: < 'i , 1 > > , 1 > > , :: pest_typed :: re_exported :: Option :: < super :: generics :: Choice_2 :: < super :: generics :: Str :: < super :: constant_wrappers :: r#w_6 > , super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < super :: constant_wrappers :: r#w_7 > , :: pest_typed :: re_exported :: Option :: < super :: generics :: Str :: < super :: constant_wrappers :: r#w_8 > > , 1 > , > > , super :: generics :: Rep :: < 'i , 1 , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_9 > > , super :: generics :: RepOnce :: < 'i , 1 , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: rules :: r#Seq :: < 'i , 1 > > , super :: rules :: r#Any :: < 'i , 1 > , 1 > > , 1 > , super :: generics :: Skipped :: < 'i > , false , Both);
    impl<'i, const INHERITED: usize> r#NonAtomic<'i, INHERITED> {
        #[doc = "A helper function to access [`Any`]."]
        #[allow(non_snake_case)]
        pub fn r#Any<'s>(&'s self) -> ::pest_typed::re_exported::Vec<&'s super::rules::r#Any<'i, 1>> {
            let res = &self.content;
            {
                let res = &res.content.3.matched;
                {
                    let res = res
                        .content
                        .iter()
                        .map(|res| {
                            let res = &res.1;
                            {
                                let res = &res.content.1.matched;
                                res
                            }
                        })
                        .collect::<::pest_typed::re_exported::Vec<_>>();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`CaseInsensitive`]."]
        #[allow(non_snake_case)]
        pub fn r#CaseInsensitive<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#CaseInsensitive<'i, 1>> {
            let res = &self.content;
            {
                let res = &res.content.0.matched;
                {
                    let res = res
                        .as_ref()
                        .and_then(|res| {
                            Some({
                                let res = &res.content.0.matched;
                                {
                                    let res = res.as_ref().and_then(|res| Some(res));
                                    res
                                }
                            })
                        })
                        .flatten();
                    res
                }
            }
        }
        #[doc = "A helper function to access [`CharRange`]."]
        #[allow(non_snake_case)]
        pub fn r#CharRange<'s>(&'s self) -> ::pest_typed::re_exported::Option<::pest_typed::re_exported::Vec<&'s super::rules::r#CharRange<'i, 1>>> {
            let res = &self.content;
            {
                let res = &res.content.0.matched;
                {
                    let res = res.as_ref().and_then(|res| {
                        Some({
                            let res = &res.content.1.matched;
                            {
                                let res = res
                                    .content
                                    .iter()
                                    .map(|res| {
                                        let res = &res.1;
                                        res
                                    })
                                    .collect::<::pest_typed::re_exported::Vec<_>>();
                                res
                            }
                        })
                    });
                    res
                }
            }
        }
        #[doc = "A helper function to access [`Tag`]."]
        #[allow(non_snake_case)]
        pub fn r#Tag<'s>(&'s self) -> ::pest_typed::re_exported::Option<::pest_typed::re_exported::Vec<&'s super::rules::r#Tag<'i, 1>>> {
            let res = &self.content;
            {
                let res = &res.content.0.matched;
                {
                    let res = res.as_ref().and_then(|res| {
                        Some({
                            let res = &res.content.2.matched;
                            {
                                let res = res
                                    .content
                                    .iter()
                                    .map(|res| {
                                        let res = &res.1;
                                        res
                                    })
                                    .collect::<::pest_typed::re_exported::Vec<_>>();
                                res
                            }
                        })
                    });
                    res
                }
            }
        }
    }
    :: pest_typed :: rule ! (r#ExactString , "Corresponds to expression: `\"r#\"`." "Normal rule." , super :: Rule , super :: Rule :: r#ExactString , super :: generics :: Str :: < super :: constant_wrappers :: r#w_10 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#ExactString<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#CaseInsensitive , "Corresponds to expression: `^\"0x\"`." "Normal rule." , super :: Rule , super :: Rule :: r#CaseInsensitive , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_11 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#CaseInsensitive<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#CharRange , "Corresponds to expression: `('0'..'9')`." "Normal rule." , super :: Rule , super :: Rule :: r#CharRange , super :: generics :: CharRange :: < '0' , '9' > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#CharRange<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Any , "Corresponds to expression: `ANY`." "Normal rule." , super :: Rule , super :: Rule :: r#Any , super :: rules :: r#ANY , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Any<'i, INHERITED> {
        #[doc = "A helper function to access [`ANY`]."]
        #[allow(non_snake_case)]
        pub fn r#ANY<'s>(&'s self) -> &'s super::rules::r#ANY {
            let res = &self.content;
            res
        }
    }
    :: pest_typed :: rule ! (r#Seq , "Corresponds to expression: `(\"1\" ~ ('2'..'9') ~ \".\")`." "Normal rule." , super :: Rule , super :: Rule :: r#Seq , super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < super :: constant_wrappers :: r#w_12 > , super :: generics :: CharRange :: < '2' , '9' > , super :: generics :: Str :: < super :: constant_wrappers :: r#w_13 > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Seq<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Choice , "Corresponds to expression: `(\"a\" | (^\"b\"+ ~ RepAtLeastOnce) | (&\"c\" ~ Choice ~ Rep ~ Opt) | Peek | PeekLeft | PeekRight | PeekLeftRight | Drop | PeekAll)`." "Normal rule." , super :: Rule , super :: Rule :: r#Choice , super :: generics :: Choice_9 :: < super :: generics :: Str :: < super :: constant_wrappers :: r#w_14 > , super :: generics :: Seq_2 :: < 'i , super :: generics :: RepOnce :: < 'i , INHERITED , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_15 > > , super :: rules :: r#RepAtLeastOnce :: < 'i , INHERITED > , INHERITED > , super :: generics :: Seq_4 :: < 'i , super :: generics :: Positive :: < 'i , super :: generics :: Str :: < super :: constant_wrappers :: r#w_16 > > , super :: rules :: r#Choice :: < 'i , INHERITED > , super :: rules :: r#Rep :: < 'i , INHERITED > , super :: rules :: r#Opt :: < 'i , INHERITED > , INHERITED > , super :: rules :: r#Peek :: < 'i , INHERITED > , super :: rules :: r#PeekLeft :: < 'i , INHERITED > , super :: rules :: r#PeekRight :: < 'i , INHERITED > , super :: rules :: r#PeekLeftRight :: < 'i , INHERITED > , super :: rules :: r#Drop :: < 'i , INHERITED > , super :: rules :: r#PeekAll :: < 'i , INHERITED > , > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Choice<'i, INHERITED> {
        #[doc = "A helper function to access [`Choice`]."]
        #[allow(non_snake_case)]
        pub fn r#Choice<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#Choice<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._2().and_then(|res| {
                    Some({
                        let res = &res.content.1.matched;
                        res
                    })
                });
                res
            }
        }
        #[doc = "A helper function to access [`Drop`]."]
        #[allow(non_snake_case)]
        pub fn r#Drop<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#Drop<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._7().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`Opt`]."]
        #[allow(non_snake_case)]
        pub fn r#Opt<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#Opt<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._2().and_then(|res| {
                    Some({
                        let res = &res.content.3.matched;
                        res
                    })
                });
                res
            }
        }
        #[doc = "A helper function to access [`Peek`]."]
        #[allow(non_snake_case)]
        pub fn r#Peek<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#Peek<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._3().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`PeekAll`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekAll<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#PeekAll<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._8().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`PeekLeft`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekLeft<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#PeekLeft<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._4().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`PeekLeftRight`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekLeftRight<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#PeekLeftRight<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._6().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`PeekRight`]."]
        #[allow(non_snake_case)]
        pub fn r#PeekRight<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#PeekRight<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._5().and_then(|res| Some(res));
                res
            }
        }
        #[doc = "A helper function to access [`Rep`]."]
        #[allow(non_snake_case)]
        pub fn r#Rep<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#Rep<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._2().and_then(|res| {
                    Some({
                        let res = &res.content.2.matched;
                        res
                    })
                });
                res
            }
        }
        #[doc = "A helper function to access [`RepAtLeastOnce`]."]
        #[allow(non_snake_case)]
        pub fn r#RepAtLeastOnce<'s>(&'s self) -> ::pest_typed::re_exported::Option<&'s super::rules::r#RepAtLeastOnce<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = res._1().and_then(|res| {
                    Some({
                        let res = &res.content.1.matched;
                        res
                    })
                });
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#Rep , "Corresponds to expression: `^\"b\"*`." "Normal rule." , super :: Rule , super :: Rule :: r#Rep , super :: generics :: Rep :: < 'i , INHERITED , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_17 > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Rep<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#RepAtLeastOnce , "Corresponds to expression: `('0'..'9')+`." "Normal rule." , super :: Rule , super :: Rule :: r#RepAtLeastOnce , super :: generics :: RepOnce :: < 'i , INHERITED , super :: generics :: CharRange :: < '0' , '9' > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#RepAtLeastOnce<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Opt , "Corresponds to expression: `\"?\"?`." "Normal rule." , super :: Rule , super :: Rule :: r#Opt , :: pest_typed :: re_exported :: Option :: < super :: generics :: Str :: < super :: constant_wrappers :: r#w_18 > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Opt<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#RepExact , "Corresponds to expression: `(RepAtLeastOnce ~ RepAtLeastOnce ~ RepAtLeastOnce)`." "Normal rule." , super :: Rule , super :: Rule :: r#RepExact , super :: generics :: Seq_3 :: < 'i , super :: rules :: r#RepAtLeastOnce :: < 'i , INHERITED > , super :: rules :: r#RepAtLeastOnce :: < 'i , INHERITED > , super :: rules :: r#RepAtLeastOnce :: < 'i , INHERITED > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#RepExact<'i, INHERITED> {
        #[doc = "A helper function to access [`RepAtLeastOnce`]."]
        #[allow(non_snake_case)]
        pub fn r#RepAtLeastOnce<'s>(&'s self) -> (&'s super::rules::r#RepAtLeastOnce<'i, INHERITED>, &'s super::rules::r#RepAtLeastOnce<'i, INHERITED>, &'s super::rules::r#RepAtLeastOnce<'i, INHERITED>) {
            let res = &self.content;
            {
                let res = (
                    {
                        let res = &res.content.0.matched;
                        res
                    },
                    {
                        let res = &res.content.1.matched;
                        res
                    },
                    {
                        let res = &res.content.2.matched;
                        res
                    },
                );
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#RepLeft , "Corresponds to expression: `(RepExact ~ RepExact*)`." "Normal rule." , super :: Rule , super :: Rule :: r#RepLeft , super :: generics :: Seq_2 :: < 'i , super :: rules :: r#RepExact :: < 'i , INHERITED > , super :: generics :: Rep :: < 'i , INHERITED , super :: rules :: r#RepExact :: < 'i , INHERITED > > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#RepLeft<'i, INHERITED> {
        #[doc = "A helper function to access [`RepExact`]."]
        #[allow(non_snake_case)]
        pub fn r#RepExact<'s>(&'s self) -> (&'s super::rules::r#RepExact<'i, INHERITED>, ::pest_typed::re_exported::Vec<&'s super::rules::r#RepExact<'i, INHERITED>>) {
            let res = &self.content;
            {
                let res = (
                    {
                        let res = &res.content.0.matched;
                        res
                    },
                    {
                        let res = &res.content.1.matched;
                        {
                            let res = res
                                .content
                                .iter()
                                .map(|res| {
                                    let res = &res.1;
                                    res
                                })
                                .collect::<::pest_typed::re_exported::Vec<_>>();
                            res
                        }
                    },
                );
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#RepRight , "Corresponds to expression: `(RepLeft? ~ RepLeft?)`." "Normal rule." , super :: Rule , super :: Rule :: r#RepRight , super :: generics :: Seq_2 :: < 'i , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#RepLeft :: < 'i , INHERITED > > , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#RepLeft :: < 'i , INHERITED > > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#RepRight<'i, INHERITED> {
        #[doc = "A helper function to access [`RepLeft`]."]
        #[allow(non_snake_case)]
        pub fn r#RepLeft<'s>(&'s self) -> (::pest_typed::re_exported::Option<&'s super::rules::r#RepLeft<'i, INHERITED>>, ::pest_typed::re_exported::Option<&'s super::rules::r#RepLeft<'i, INHERITED>>) {
            let res = &self.content;
            {
                let res = (
                    {
                        let res = &res.content.0.matched;
                        {
                            let res = res.as_ref().and_then(|res| Some(res));
                            res
                        }
                    },
                    {
                        let res = &res.content.1.matched;
                        {
                            let res = res.as_ref().and_then(|res| Some(res));
                            res
                        }
                    },
                );
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#RepLeftRight , "Corresponds to expression: `(RepRight ~ RepRight?)`." "Normal rule." , super :: Rule , super :: Rule :: r#RepLeftRight , super :: generics :: Seq_2 :: < 'i , super :: rules :: r#RepRight :: < 'i , INHERITED > , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#RepRight :: < 'i , INHERITED > > , INHERITED > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#RepLeftRight<'i, INHERITED> {
        #[doc = "A helper function to access [`RepRight`]."]
        #[allow(non_snake_case)]
        pub fn r#RepRight<'s>(&'s self) -> (&'s super::rules::r#RepRight<'i, INHERITED>, ::pest_typed::re_exported::Option<&'s super::rules::r#RepRight<'i, INHERITED>>) {
            let res = &self.content;
            {
                let res = (
                    {
                        let res = &res.content.0.matched;
                        res
                    },
                    {
                        let res = &res.content.1.matched;
                        {
                            let res = res.as_ref().and_then(|res| Some(res));
                            res
                        }
                    },
                );
                res
            }
        }
    }
    :: pest_typed :: rule ! (r#Pos , "Corresponds to expression: `(SOI ~ RepLeftRight ~ RepLeftRight ~ RepLeftRight? ~ RepLeftRight?)`." "Normal rule." , super :: Rule , super :: Rule :: r#Pos , super :: generics :: Positive :: < 'i , super :: generics :: Seq_5 :: < 'i , super :: rules :: r#SOI , super :: rules :: r#RepLeftRight :: < 'i , INHERITED > , super :: rules :: r#RepLeftRight :: < 'i , INHERITED > , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#RepLeftRight :: < 'i , INHERITED > > , :: pest_typed :: re_exported :: Option :: < super :: rules :: r#RepLeftRight :: < 'i , INHERITED > > , INHERITED > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Pos<'i, INHERITED> {
        #[doc = "A helper function to access [`RepLeftRight`]."]
        #[allow(non_snake_case)]
        pub fn r#RepLeftRight<'s>(&'s self) -> (&'s super::rules::r#RepLeftRight<'i, INHERITED>, &'s super::rules::r#RepLeftRight<'i, INHERITED>, ::pest_typed::re_exported::Option<&'s super::rules::r#RepLeftRight<'i, INHERITED>>, ::pest_typed::re_exported::Option<&'s super::rules::r#RepLeftRight<'i, INHERITED>>) {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = (
                        {
                            let res = &res.content.1.matched;
                            res
                        },
                        {
                            let res = &res.content.2.matched;
                            res
                        },
                        {
                            let res = &res.content.3.matched;
                            {
                                let res = res.as_ref().and_then(|res| Some(res));
                                res
                            }
                        },
                        {
                            let res = &res.content.4.matched;
                            {
                                let res = res.as_ref().and_then(|res| Some(res));
                                res
                            }
                        },
                    );
                    res
                }
            }
        }
        #[doc = "A helper function to access [`SOI`]."]
        #[allow(non_snake_case)]
        pub fn r#SOI<'s>(&'s self) -> &'s super::rules::r#SOI {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.0.matched;
                    res
                }
            }
        }
    }
    :: pest_typed :: rule ! (r#Neg , "Corresponds to expression: `(EOI ~ Pos)`." "Normal rule." , super :: Rule , super :: Rule :: r#Neg , super :: generics :: Negative :: < 'i , super :: generics :: Seq_2 :: < 'i , super :: rules :: r#EOI :: < 'i > , super :: rules :: r#Pos :: < 'i , INHERITED > , INHERITED > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Neg<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Push , "Corresponds to expression: `(RepLeft* ~ Neg ~ ExactString+ ~ Push ~ Pop ~ Push ~ PopAll)`." "Normal rule." , super :: Rule , super :: Rule :: r#Push , super :: generics :: Push :: < 'i , super :: generics :: Seq_7 :: < 'i , super :: generics :: Rep :: < 'i , INHERITED , super :: rules :: r#RepLeft :: < 'i , INHERITED > > , super :: rules :: r#Neg :: < 'i , INHERITED > , super :: generics :: RepOnce :: < 'i , INHERITED , super :: rules :: r#ExactString :: < 'i , INHERITED > > , super :: rules :: r#Push :: < 'i , INHERITED > , super :: rules :: r#Pop :: < 'i , INHERITED > , super :: rules :: r#Push :: < 'i , INHERITED > , super :: rules :: r#PopAll :: < 'i , INHERITED > , INHERITED > > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Push<'i, INHERITED> {
        #[doc = "A helper function to access [`ExactString`]."]
        #[allow(non_snake_case)]
        pub fn r#ExactString<'s>(&'s self) -> ::pest_typed::re_exported::Vec<&'s super::rules::r#ExactString<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.2.matched;
                    {
                        let res = res
                            .content
                            .iter()
                            .map(|res| {
                                let res = &res.1;
                                res
                            })
                            .collect::<::pest_typed::re_exported::Vec<_>>();
                        res
                    }
                }
            }
        }
        #[doc = "A helper function to access [`Neg`]."]
        #[allow(non_snake_case)]
        pub fn r#Neg<'s>(&'s self) -> &'s super::rules::r#Neg<'i, INHERITED> {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.1.matched;
                    res
                }
            }
        }
        #[doc = "A helper function to access [`Pop`]."]
        #[allow(non_snake_case)]
        pub fn r#Pop<'s>(&'s self) -> &'s super::rules::r#Pop<'i, INHERITED> {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.4.matched;
                    res
                }
            }
        }
        #[doc = "A helper function to access [`PopAll`]."]
        #[allow(non_snake_case)]
        pub fn r#PopAll<'s>(&'s self) -> &'s super::rules::r#PopAll<'i, INHERITED> {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.6.matched;
                    res
                }
            }
        }
        #[doc = "A helper function to access [`Push`]."]
        #[allow(non_snake_case)]
        pub fn r#Push<'s>(&'s self) -> (&'s super::rules::r#Push<'i, INHERITED>, &'s super::rules::r#Push<'i, INHERITED>) {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = (
                        {
                            let res = &res.content.3.matched;
                            res
                        },
                        {
                            let res = &res.content.5.matched;
                            res
                        },
                    );
                    res
                }
            }
        }
        #[doc = "A helper function to access [`RepLeft`]."]
        #[allow(non_snake_case)]
        pub fn r#RepLeft<'s>(&'s self) -> ::pest_typed::re_exported::Vec<&'s super::rules::r#RepLeft<'i, INHERITED>> {
            let res = &self.content;
            {
                let res = &res.content;
                {
                    let res = &res.content.0.matched;
                    {
                        let res = res
                            .content
                            .iter()
                            .map(|res| {
                                let res = &res.1;
                                res
                            })
                            .collect::<::pest_typed::re_exported::Vec<_>>();
                        res
                    }
                }
            }
        }
    }
    :: pest_typed :: rule ! (r#Pop , "Corresponds to expression: `POP`." "Normal rule." , super :: Rule , super :: Rule :: r#Pop , super :: rules :: r#POP :: < 'i > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Pop<'i, INHERITED> {
        #[doc = "A helper function to access [`POP`]."]
        #[allow(non_snake_case)]
        pub fn r#POP<'s>(&'s self) -> &'s super::rules::r#POP<'i> {
            let res = &self.content;
            res
        }
    }
    :: pest_typed :: rule ! (r#PopAll , "Corresponds to expression: `POP_ALL`." "Normal rule." , super :: Rule , super :: Rule :: r#PopAll , super :: rules :: r#POP_ALL :: < 'i > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#PopAll<'i, INHERITED> {
        #[doc = "A helper function to access [`POP_ALL`]."]
        #[allow(non_snake_case)]
        pub fn r#POP_ALL<'s>(&'s self) -> &'s super::rules::r#POP_ALL<'i> {
            let res = &self.content;
            res
        }
    }
    :: pest_typed :: rule ! (r#Peek , "Corresponds to expression: `PEEK[0..]`." "Normal rule." , super :: Rule , super :: Rule :: r#Peek , super :: generics :: PeekSlice1 :: < 0i32 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Peek<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#PeekLeft , "Corresponds to expression: `PEEK[1..]`." "Normal rule." , super :: Rule , super :: Rule :: r#PeekLeft , super :: generics :: PeekSlice1 :: < 1i32 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#PeekLeft<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#PeekRight , "Corresponds to expression: `PEEK[0..]`." "Normal rule." , super :: Rule , super :: Rule :: r#PeekRight , super :: generics :: PeekSlice1 :: < 0i32 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#PeekRight<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#PeekLeftRight , "Corresponds to expression: `PEEK[1..2]`." "Normal rule." , super :: Rule , super :: Rule :: r#PeekLeftRight , super :: generics :: PeekSlice2 :: < 1i32 , 2i32 > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#PeekLeftRight<'i, INHERITED> {}
    :: pest_typed :: rule ! (r#Drop , "Corresponds to expression: `DROP`." "Normal rule." , super :: Rule , super :: Rule :: r#Drop , super :: rules :: r#DROP , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#Drop<'i, INHERITED> {
        #[doc = "A helper function to access [`DROP`]."]
        #[allow(non_snake_case)]
        pub fn r#DROP<'s>(&'s self) -> &'s super::rules::r#DROP {
            let res = &self.content;
            res
        }
    }
    :: pest_typed :: rule ! (r#PeekAll , "Corresponds to expression: `PEEK_ALL`." "Normal rule." , super :: Rule , super :: Rule :: r#PeekAll , super :: rules :: r#PEEK_ALL :: < 'i > , super :: generics :: Skipped :: < 'i > , INHERITED , Both);
    impl<'i, const INHERITED: usize> r#PeekAll<'i, INHERITED> {
        #[doc = "A helper function to access [`PEEK_ALL`]."]
        #[allow(non_snake_case)]
        pub fn r#PEEK_ALL<'s>(&'s self) -> &'s super::rules::r#PEEK_ALL<'i> {
            let res = &self.content;
            res
        }
    }
    use super::unicode::*;
    ::pest_typed::rule_eoi!(EOI, super::Rule);
    #[allow(non_camel_case_types)]
    pub type r#ANY = ::pest_typed::predefined_node::ANY;
    #[allow(non_camel_case_types)]
    pub type r#SOI = ::pest_typed::predefined_node::SOI;
    #[allow(non_camel_case_types)]
    pub type r#PEEK_ALL<'i> = ::pest_typed::predefined_node::PEEK_ALL<'i>;
    #[allow(non_camel_case_types)]
    pub type r#POP<'i> = ::pest_typed::predefined_node::POP<'i>;
    #[allow(non_camel_case_types)]
    pub type r#POP_ALL<'i> = ::pest_typed::predefined_node::POP_ALL<'i>;
    #[allow(non_camel_case_types)]
    pub type r#DROP = ::pest_typed::predefined_node::DROP;
    #[allow(non_camel_case_types)]
    pub type r#WHITESPACE<'i> = ::pest_typed::predefined_node::AlwaysFail<'i>;
    #[allow(non_camel_case_types)]
    pub type r#COMMENT<'i> = ::pest_typed::predefined_node::AlwaysFail<'i>;
}
#[doc(hidden)]
mod generics {
    use pest_typed::{predefined_node, StringArrayWrapper, StringWrapper, TypedNode};
    pub type Skipped<'i> = predefined_node::Empty<'i>;
    pub type Str<Wrapper: StringWrapper> = predefined_node::Str<Wrapper>;
    pub type Insens<'i, Wrapper: StringWrapper> = predefined_node::Insens<'i, Wrapper>;
    pub type PeekSlice2<const START: ::core::primitive::i32, const END: ::core::primitive::i32> = predefined_node::PeekSlice2<START, END>;
    pub type PeekSlice1<const START: ::core::primitive::i32> = predefined_node::PeekSlice1<START>;
    pub type Push<'i, T: TypedNode<'i, super::Rule>> = predefined_node::Push<T>;
    pub type Skip<'i, Strings: StringArrayWrapper> = predefined_node::Skip<'i, Strings>;
    pub type CharRange<const START: ::core::primitive::char, const END: ::core::primitive::char> = predefined_node::CharRange<START, END>;
    pub type Positive<'i, T: TypedNode<'i, super::Rule>> = predefined_node::Positive<T>;
    pub type Negative<'i, T: TypedNode<'i, super::Rule>> = predefined_node::Negative<T>;
    use pest_typed::sequence::Seq2;
    pub type Seq_2<'i, T0, T1, const SKIP: usize> = Seq2<(::pest_typed::predefined_node::Skipped<T0, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T1, Skipped<'i>, SKIP>)>;
    use pest_typed::sequence::Seq3;
    pub type Seq_3<'i, T0, T1, T2, const SKIP: usize> = Seq3<(::pest_typed::predefined_node::Skipped<T0, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T1, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T2, Skipped<'i>, SKIP>)>;
    use pest_typed::sequence::Seq4;
    pub type Seq_4<'i, T0, T1, T2, T3, const SKIP: usize> = Seq4<(::pest_typed::predefined_node::Skipped<T0, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T1, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T2, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T3, Skipped<'i>, SKIP>)>;
    use pest_typed::sequence::Seq5;
    pub type Seq_5<'i, T0, T1, T2, T3, T4, const SKIP: usize> = Seq5<(::pest_typed::predefined_node::Skipped<T0, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T1, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T2, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T3, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T4, Skipped<'i>, SKIP>)>;
    use pest_typed::sequence::Seq7;
    pub type Seq_7<'i, T0, T1, T2, T3, T4, T5, T6, const SKIP: usize> = Seq7<(::pest_typed::predefined_node::Skipped<T0, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T1, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T2, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T3, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T4, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T5, Skipped<'i>, SKIP>), (::pest_typed::predefined_node::Skipped<T6, Skipped<'i>, SKIP>)>;
    use pest_typed::choices::Choice2;
    pub type Choice_2<T0, T1> = Choice2<T0, T1>;
    use pest_typed::choices::Choice9;
    pub type Choice_9<T0, T1, T2, T3, T4, T5, T6, T7, T8> = Choice9<T0, T1, T2, T3, T4, T5, T6, T7, T8>;
    pub type Rep<'i, const SKIP: usize, T> = predefined_node::Rep<T, Skipped<'i>, SKIP>;
    pub type RepOnce<'i, const SKIP: usize, T> = predefined_node::RepOnce<T, Skipped<'i>, SKIP>;
}
pub mod pairs {
    pub type r#Any<'i> = super::rules::r#Any<'i, 1>;
    pub type r#Atomic<'i> = super::rules::r#Atomic<'i, 1>;
    pub type r#CaseInsensitive<'i> = super::rules::r#CaseInsensitive<'i, 1>;
    pub type r#CharRange<'i> = super::rules::r#CharRange<'i, 1>;
    pub type r#Choice<'i> = super::rules::r#Choice<'i, 1>;
    pub type r#CompoundAtomic<'i> = super::rules::r#CompoundAtomic<'i, 1>;
    pub type r#Drop<'i> = super::rules::r#Drop<'i, 1>;
    pub type r#ExactString<'i> = super::rules::r#ExactString<'i, 1>;
    pub type r#Neg<'i> = super::rules::r#Neg<'i, 1>;
    pub type r#NonAtomic<'i> = super::rules::r#NonAtomic<'i, 1>;
    pub type r#Opt<'i> = super::rules::r#Opt<'i, 1>;
    pub type r#Peek<'i> = super::rules::r#Peek<'i, 1>;
    pub type r#PeekAll<'i> = super::rules::r#PeekAll<'i, 1>;
    pub type r#PeekLeft<'i> = super::rules::r#PeekLeft<'i, 1>;
    pub type r#PeekLeftRight<'i> = super::rules::r#PeekLeftRight<'i, 1>;
    pub type r#PeekRight<'i> = super::rules::r#PeekRight<'i, 1>;
    pub type r#Pop<'i> = super::rules::r#Pop<'i, 1>;
    pub type r#PopAll<'i> = super::rules::r#PopAll<'i, 1>;
    pub type r#Pos<'i> = super::rules::r#Pos<'i, 1>;
    pub type r#Push<'i> = super::rules::r#Push<'i, 1>;
    pub type r#Regular<'i> = super::rules::r#Regular<'i, 1>;
    pub type r#Rep<'i> = super::rules::r#Rep<'i, 1>;
    pub type r#RepAtLeastOnce<'i> = super::rules::r#RepAtLeastOnce<'i, 1>;
    pub type r#RepExact<'i> = super::rules::r#RepExact<'i, 1>;
    pub type r#RepLeft<'i> = super::rules::r#RepLeft<'i, 1>;
    pub type r#RepLeftRight<'i> = super::rules::r#RepLeftRight<'i, 1>;
    pub type r#RepRight<'i> = super::rules::r#RepRight<'i, 1>;
    pub type r#Seq<'i> = super::rules::r#Seq<'i, 1>;
    pub type r#Silent<'i> = super::rules::r#Silent<'i, 1>;
    pub type r#Tag<'i> = super::rules::r#Tag<'i, 1>;
}
#[allow(clippy::all)]
impl ::pest_typed::TypedParser<Rule> for Parser {
    fn parse<'i, T: ::pest_typed::ParsableTypedNode<'i, Rule>>(input: &'i ::core::primitive::str) -> ::pest_typed::re_exported::Result<T, ::pest_typed::error::Error<Rule>> {
        T::parse(input)
    }
}
