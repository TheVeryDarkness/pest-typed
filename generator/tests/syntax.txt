# [doc = ""] # [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum Rule { EOI , # [doc = "Regular rule."] r#Regular , # [doc = "Atomic rule."] r#Atomic , # [doc = "Silent rule."] r#Silent , # [doc = "Compound atomic rule."] r#CompoundAtomic , # [doc = "Tagged rule."] r#Tag , # [doc = "Non-atomic rule."] r#NonAtomic , r#ExactString , r#CaseInsensitive , r#CharRange , r#Any , r#Seq , r#Choice , r#Rep , r#RepAtLeastOnce , r#Opt , r#RepExact , r#RepLeft , r#RepRight , r#RepLeftRight , r#Pos , r#Neg , r#Push , r#Pop , r#PopAll , r#Peek , r#PeekLeft , r#PeekRight , r#PeekLeftRight , r#Drop , r#PeekAll } # [doc (hidden)] mod rule_wrappers { # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Regular ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Regular { const RULE : super :: Rule = super :: Rule :: r#Regular ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Atomic ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Atomic { const RULE : super :: Rule = super :: Rule :: r#Atomic ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Silent ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Silent { const RULE : super :: Rule = super :: Rule :: r#Silent ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CompoundAtomic ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#CompoundAtomic { const RULE : super :: Rule = super :: Rule :: r#CompoundAtomic ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Tag ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Tag { const RULE : super :: Rule = super :: Rule :: r#Tag ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#NonAtomic ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#NonAtomic { const RULE : super :: Rule = super :: Rule :: r#NonAtomic ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#ExactString ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#ExactString { const RULE : super :: Rule = super :: Rule :: r#ExactString ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CaseInsensitive ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#CaseInsensitive { const RULE : super :: Rule = super :: Rule :: r#CaseInsensitive ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CharRange ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#CharRange { const RULE : super :: Rule = super :: Rule :: r#CharRange ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Any ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Any { const RULE : super :: Rule = super :: Rule :: r#Any ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Seq ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Seq { const RULE : super :: Rule = super :: Rule :: r#Seq ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Choice ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Choice { const RULE : super :: Rule = super :: Rule :: r#Choice ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Rep ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Rep { const RULE : super :: Rule = super :: Rule :: r#Rep ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepAtLeastOnce ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#RepAtLeastOnce { const RULE : super :: Rule = super :: Rule :: r#RepAtLeastOnce ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Opt ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Opt { const RULE : super :: Rule = super :: Rule :: r#Opt ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepExact ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#RepExact { const RULE : super :: Rule = super :: Rule :: r#RepExact ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepLeft ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#RepLeft { const RULE : super :: Rule = super :: Rule :: r#RepLeft ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepRight ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#RepRight { const RULE : super :: Rule = super :: Rule :: r#RepRight ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepLeftRight ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#RepLeftRight { const RULE : super :: Rule = super :: Rule :: r#RepLeftRight ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Pos ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Pos { const RULE : super :: Rule = super :: Rule :: r#Pos ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Neg ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Neg { const RULE : super :: Rule = super :: Rule :: r#Neg ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Push ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Push { const RULE : super :: Rule = super :: Rule :: r#Push ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Pop ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Pop { const RULE : super :: Rule = super :: Rule :: r#Pop ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PopAll ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#PopAll { const RULE : super :: Rule = super :: Rule :: r#PopAll ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Peek ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Peek { const RULE : super :: Rule = super :: Rule :: r#Peek ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekLeft ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekLeft { const RULE : super :: Rule = super :: Rule :: r#PeekLeft ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekRight ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekRight { const RULE : super :: Rule = super :: Rule :: r#PeekRight ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekLeftRight ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekLeftRight { const RULE : super :: Rule = super :: Rule :: r#PeekLeftRight ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Drop ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#Drop { const RULE : super :: Rule = super :: Rule :: r#Drop ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekAll ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekAll { const RULE : super :: Rule = super :: Rule :: r#PeekAll ; type Rule = super :: Rule ; } # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#EOI ; impl :: pest_typed :: RuleWrapper < super :: Rule > for r#EOI { const RULE : super :: Rule = super :: Rule :: r#EOI ; type Rule = super :: Rule ; } } # [doc (hidden)] mod unicode { } # [doc (hidden)] mod constant_wrappers { # [doc = "A wrapper for `\"+\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_0 () ; impl :: pest_typed :: StringWrapper for r#w_0 { const CONTENT : & 'static :: core :: primitive :: str = "+" ; } # [doc = "A wrapper for `\"(\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_1 () ; impl :: pest_typed :: StringWrapper for r#w_1 { const CONTENT : & 'static :: core :: primitive :: str = "(" ; } # [doc = "A wrapper for `\")\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_2 () ; impl :: pest_typed :: StringWrapper for r#w_2 { const CONTENT : & 'static :: core :: primitive :: str = ")" ; } # [doc = "A wrapper for `\"\\\"\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_3 () ; impl :: pest_typed :: StringWrapper for r#w_3 { const CONTENT : & 'static :: core :: primitive :: str = "\"" ; } # [doc = "A wrapper for `\"\\\"\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_4 () ; impl :: pest_typed :: StringWrapper for r#w_4 { const CONTENT : & 'static :: core :: primitive :: str = "\"" ; } # [doc = "A wrapper for `\"\\\"\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_5 () ; impl :: pest_typed :: StringWrapper for r#w_5 { const CONTENT : & 'static :: core :: primitive :: str = "\"" ; } # [doc = "A wrapper for `\"a\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_6 () ; impl :: pest_typed :: StringWrapper for r#w_6 { const CONTENT : & 'static :: core :: primitive :: str = "a" ; } # [doc = "A wrapper for `\"b\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_7 () ; impl :: pest_typed :: StringWrapper for r#w_7 { const CONTENT : & 'static :: core :: primitive :: str = "b" ; } # [doc = "A wrapper for `\"BB\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_8 () ; impl :: pest_typed :: StringWrapper for r#w_8 { const CONTENT : & 'static :: core :: primitive :: str = "BB" ; } # [doc = "A wrapper for `\"c\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_9 () ; impl :: pest_typed :: StringWrapper for r#w_9 { const CONTENT : & 'static :: core :: primitive :: str = "c" ; } # [doc = "A wrapper for `\"r#\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_10 () ; impl :: pest_typed :: StringWrapper for r#w_10 { const CONTENT : & 'static :: core :: primitive :: str = "r#" ; } # [doc = "A wrapper for `\"0x\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_11 () ; impl :: pest_typed :: StringWrapper for r#w_11 { const CONTENT : & 'static :: core :: primitive :: str = "0x" ; } # [doc = "A wrapper for `\"1\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_12 () ; impl :: pest_typed :: StringWrapper for r#w_12 { const CONTENT : & 'static :: core :: primitive :: str = "1" ; } # [doc = "A wrapper for `\".\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_13 () ; impl :: pest_typed :: StringWrapper for r#w_13 { const CONTENT : & 'static :: core :: primitive :: str = "." ; } # [doc = "A wrapper for `\"a\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_14 () ; impl :: pest_typed :: StringWrapper for r#w_14 { const CONTENT : & 'static :: core :: primitive :: str = "a" ; } # [doc = "A wrapper for `\"b\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_15 () ; impl :: pest_typed :: StringWrapper for r#w_15 { const CONTENT : & 'static :: core :: primitive :: str = "b" ; } # [doc = "A wrapper for `\"c\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_16 () ; impl :: pest_typed :: StringWrapper for r#w_16 { const CONTENT : & 'static :: core :: primitive :: str = "c" ; } # [doc = "A wrapper for `\"b\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_17 () ; impl :: pest_typed :: StringWrapper for r#w_17 { const CONTENT : & 'static :: core :: primitive :: str = "b" ; } # [doc = "A wrapper for `\"?\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_18 () ; impl :: pest_typed :: StringWrapper for r#w_18 { const CONTENT : & 'static :: core :: primitive :: str = "?" ; } # [doc = "A wrapper for `\"a\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_19 () ; impl :: pest_typed :: StringWrapper for r#w_19 { const CONTENT : & 'static :: core :: primitive :: str = "a" ; } # [doc = "A wrapper for `\"a\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_20 () ; impl :: pest_typed :: StringWrapper for r#w_20 { const CONTENT : & 'static :: core :: primitive :: str = "a" ; } # [doc = "A wrapper for `\"a\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_21 () ; impl :: pest_typed :: StringWrapper for r#w_21 { const CONTENT : & 'static :: core :: primitive :: str = "a" ; } # [doc = "A wrapper for `\"0\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_22 () ; impl :: pest_typed :: StringWrapper for r#w_22 { const CONTENT : & 'static :: core :: primitive :: str = "0" ; } # [doc = "A wrapper for `\"0\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_23 () ; impl :: pest_typed :: StringWrapper for r#w_23 { const CONTENT : & 'static :: core :: primitive :: str = "0" ; } # [doc = "A wrapper for `\"1\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_24 () ; impl :: pest_typed :: StringWrapper for r#w_24 { const CONTENT : & 'static :: core :: primitive :: str = "1" ; } # [doc = "A wrapper for `\"1\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_25 () ; impl :: pest_typed :: StringWrapper for r#w_25 { const CONTENT : & 'static :: core :: primitive :: str = "1" ; } # [doc = "A wrapper for `\"2\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_26 () ; impl :: pest_typed :: StringWrapper for r#w_26 { const CONTENT : & 'static :: core :: primitive :: str = "2" ; } # [doc = "A wrapper for `\"2\"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_27 () ; impl :: pest_typed :: StringWrapper for r#w_27 { const CONTENT : & 'static :: core :: primitive :: str = "2" ; } # [doc = "A wrapper for `\" \"`."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#w_28 () ; impl :: pest_typed :: StringWrapper for r#w_28 { const CONTENT : & 'static :: core :: primitive :: str = " " ; } } mod tags { } # [doc = "Definitions of statically typed nodes generated by pest-generator."] pub mod pairs { use :: pest_typed :: iterators :: { Pair as _ , Pairs as _ } ; # [doc = "Corresponds to expression: `(('0'..'9')+ ~ \"+\" ~ ('0'..'9')+)`."] # [doc = "Normal rule."] # [doc = ""] # [doc = "Regular rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Regular < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_3 :: < 'i , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_0 > , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Regular < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Regular < 'i > { type Target = super :: generics :: Seq_3 :: < 'i , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_0 > , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Regular < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Regular < 'i > { const RULE : super :: Rule = super :: Rule :: r#Regular ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Regular < 'i > { type Inner = super :: generics :: Seq_3 :: < 'i , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_0 > , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Regular < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_3 :: < 'i , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_0 > , super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Regular < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Regular < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Regular") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Regular < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Regular < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Regular < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `('0'..'9')+`."] # [doc = "Atomic rule."] # [doc = ""] # [doc = "Atomic rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Atomic < 'i > { # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Atomic < 'i > { } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Atomic < 'i > { const RULE : super :: Rule = super :: Rule :: r#Atomic ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Atomic < 'i > { type Inner = super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Atomic < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , _) = super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > :: try_parse_with :: < true > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Atomic < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Atomic < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Atomic") . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Atomic < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Atomic < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { :: pest_typed :: re_exported :: Vec :: new () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { :: pest_typed :: re_exported :: Vec :: new () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Atomic < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"(\" | \")\")`."] # [doc = "Normal rule."] # [doc = ""] # [doc = "Silent rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Silent < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > , } impl < 'i > r#Silent < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Silent < 'i > { type Target = super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Silent < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Silent < 'i > { const RULE : super :: Rule = super :: Rule :: r#Silent ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Silent < 'i > { type Inner = super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Silent < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let (input , content) = super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; Ok ((input , Self { content })) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Silent < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Silent < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Silent") . field ("content" , & self . content) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Silent < 'i > { type Iter = < super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > as :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule >> :: Iter ; type IntoIter = < super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_1 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_2 > , > as :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule >> :: IntoIter ; fn iter (& 'n self) -> Self :: Iter { self . content . iter () } fn into_iter (self) -> Self :: IntoIter { self . content . into_iter () } } # [doc = "Corresponds to expression: `(\"\"\" ~ (!\"\"\" ~ ANY)* ~ \"\"\")`."] # [doc = "Atomic rule."] # [doc = ""] # [doc = "Compound atomic rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CompoundAtomic < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_3 > , super :: generics :: Rep :: < 'i , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_4 > > , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_5 > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#CompoundAtomic < 'i > { # [doc = "A helper function to access [`ANY`]."] # [allow (non_snake_case)] pub fn r#ANY < 's > (& 's self) -> :: pest_typed :: re_exported :: Vec :: < & 's super :: pairs :: r#ANY :: < 'i > > { let res = & self . content ; { let res = & res . content . 1 ; { let res = res . content . iter () . map (| res | { let res = & res . content . 1 ; { let res = res . content . deref () ; res } }) . collect :: < :: pest_typed :: re_exported :: Vec < _ >> () ; res } } } } impl < 'i > :: core :: ops :: Deref for r#CompoundAtomic < 'i > { type Target = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_3 > , super :: generics :: Rep :: < 'i , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_4 > > , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_5 > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#CompoundAtomic < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#CompoundAtomic < 'i > { const RULE : super :: Rule = super :: Rule :: r#CompoundAtomic ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#CompoundAtomic < 'i > { type Inner = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_3 > , super :: generics :: Rep :: < 'i , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_4 > > , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_5 > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#CompoundAtomic < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_3 > , super :: generics :: Rep :: < 'i , super :: generics :: Seq_2 :: < 'i , super :: generics :: Negative :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_4 > > , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , > , > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_5 > , > :: try_parse_with :: < true > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#CompoundAtomic < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#CompoundAtomic < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("CompoundAtomic") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#CompoundAtomic < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#CompoundAtomic < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#CompoundAtomic < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(ANY ~ (#Second = Any))`."] # [doc = "Normal rule."] # [doc = ""] # [doc = "Tagged rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Tag < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_2 :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , super :: generics :: Box :: < 'i , super :: pairs :: r#Any :: < 'i >> , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Tag < 'i > { # [doc = "A helper function to access [`ANY`]."] # [allow (non_snake_case)] pub fn r#ANY < 's > (& 's self) -> & 's super :: pairs :: r#ANY :: < 'i > { let res = & self . content ; { let res = & res . content . 0 ; { let res = res . content . deref () ; res } } } # [doc = "A helper function to access [`Any`]."] # [allow (non_snake_case)] pub fn r#Any < 's > (& 's self) -> & 's super :: pairs :: r#Any :: < 'i > { let res = & self . content ; { let res = & res . content . 1 ; { let res = res . content . deref () ; res } } } } impl < 'i > :: core :: ops :: Deref for r#Tag < 'i > { type Target = super :: generics :: Seq_2 :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , super :: generics :: Box :: < 'i , super :: pairs :: r#Any :: < 'i >> , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Tag < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Tag < 'i > { const RULE : super :: Rule = super :: Rule :: r#Tag ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Tag < 'i > { type Inner = super :: generics :: Seq_2 :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , super :: generics :: Box :: < 'i , super :: pairs :: r#Any :: < 'i >> , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Tag < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_2 :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , super :: generics :: Box :: < 'i , super :: pairs :: r#Any :: < 'i >> , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Tag < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Tag < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Tag") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Tag < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Tag < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Tag < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"a\" ~ (\"b\" | \"BB\")+ ~ ^\"c\"*)`."] # [doc = "Non-atomic rule."] # [doc = ""] # [doc = "Non-atomic rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#NonAtomic < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_6 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_7 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_8 > , > , > , super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_9 > , > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#NonAtomic < 'i > { } impl < 'i > :: core :: ops :: Deref for r#NonAtomic < 'i > { type Target = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_6 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_7 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_8 > , > , > , super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_9 > , > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#NonAtomic < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#NonAtomic < 'i > { const RULE : super :: Rule = super :: Rule :: r#NonAtomic ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#NonAtomic < 'i > { type Inner = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_6 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_7 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_8 > , > , > , super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_9 > , > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#NonAtomic < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_6 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Choice_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_7 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_8 > , > , > , super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_9 > , > , > :: try_parse_with :: < false > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#NonAtomic < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#NonAtomic < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("NonAtomic") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#NonAtomic < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#NonAtomic < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#NonAtomic < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `\"r#\"`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#ExactString < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_10 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#ExactString < 'i > { } impl < 'i > :: core :: ops :: Deref for r#ExactString < 'i > { type Target = super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_10 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#ExactString < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#ExactString < 'i > { const RULE : super :: Rule = super :: Rule :: r#ExactString ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#ExactString < 'i > { type Inner = super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_10 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#ExactString < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_10 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#ExactString < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#ExactString < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("ExactString") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#ExactString < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#ExactString < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#ExactString < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `^\"0x\"`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CaseInsensitive < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_11 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#CaseInsensitive < 'i > { } impl < 'i > :: core :: ops :: Deref for r#CaseInsensitive < 'i > { type Target = super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_11 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#CaseInsensitive < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#CaseInsensitive < 'i > { const RULE : super :: Rule = super :: Rule :: r#CaseInsensitive ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#CaseInsensitive < 'i > { type Inner = super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_11 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#CaseInsensitive < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_11 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#CaseInsensitive < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#CaseInsensitive < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("CaseInsensitive") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#CaseInsensitive < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#CaseInsensitive < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#CaseInsensitive < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `('a'..'f')`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#CharRange < 'i > { # [doc = "Matched content."] pub content : super :: generics :: CharRange :: < 'i , 'a' , 'f' > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#CharRange < 'i > { } impl < 'i > :: core :: ops :: Deref for r#CharRange < 'i > { type Target = super :: generics :: CharRange :: < 'i , 'a' , 'f' > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#CharRange < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#CharRange < 'i > { const RULE : super :: Rule = super :: Rule :: r#CharRange ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#CharRange < 'i > { type Inner = super :: generics :: CharRange :: < 'i , 'a' , 'f' > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#CharRange < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: CharRange :: < 'i , 'a' , 'f' > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#CharRange < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#CharRange < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("CharRange") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#CharRange < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#CharRange < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#CharRange < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `ANY`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Any < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Any < 'i > { # [doc = "A helper function to access [`ANY`]."] # [allow (non_snake_case)] pub fn r#ANY < 's > (& 's self) -> & 's super :: pairs :: r#ANY :: < 'i > { let res = & self . content ; { let res = res . content . deref () ; res } } } impl < 'i > :: core :: ops :: Deref for r#Any < 'i > { type Target = super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Any < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Any < 'i > { const RULE : super :: Rule = super :: Rule :: r#Any ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Any < 'i > { type Inner = super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Any < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Box :: < 'i , super :: pairs :: r#ANY :: < 'i >> :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Any < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Any < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Any") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Any < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Any < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Any < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"1\" ~ ('2'..'9') ~ \".\")`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Seq < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_12 > , super :: generics :: CharRange :: < 'i , '2' , '9' > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_13 > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Seq < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Seq < 'i > { type Target = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_12 > , super :: generics :: CharRange :: < 'i , '2' , '9' > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_13 > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Seq < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Seq < 'i > { const RULE : super :: Rule = super :: Rule :: r#Seq ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Seq < 'i > { type Inner = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_12 > , super :: generics :: CharRange :: < 'i , '2' , '9' > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_13 > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Seq < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_12 > , super :: generics :: CharRange :: < 'i , '2' , '9' > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_13 > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Seq < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Seq < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Seq") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Seq < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Seq < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Seq < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"a\" | ^\"b\"+ | &\"c\")`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Choice < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Choice_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_14 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_15 > , > , super :: generics :: Positive :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_16 > > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Choice < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Choice < 'i > { type Target = super :: generics :: Choice_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_14 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_15 > , > , super :: generics :: Positive :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_16 > > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Choice < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Choice < 'i > { const RULE : super :: Rule = super :: Rule :: r#Choice ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Choice < 'i > { type Inner = super :: generics :: Choice_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_14 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_15 > , > , super :: generics :: Positive :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_16 > > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Choice < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Choice_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_14 > , super :: generics :: RepOnce :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_15 > , > , super :: generics :: Positive :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_16 > > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Choice < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Choice < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Choice") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Choice < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Choice < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Choice < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `^\"b\"*`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Rep < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_17 > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Rep < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Rep < 'i > { type Target = super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_17 > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Rep < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Rep < 'i > { const RULE : super :: Rule = super :: Rule :: r#Rep ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Rep < 'i > { type Inner = super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_17 > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Rep < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Rep :: < 'i , super :: generics :: Insens :: < 'i , super :: constant_wrappers :: r#w_17 > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Rep < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Rep < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Rep") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Rep < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Rep < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Rep < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `('0'..'9')+`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepAtLeastOnce < 'i > { # [doc = "Matched content."] pub content : super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#RepAtLeastOnce < 'i > { } impl < 'i > :: core :: ops :: Deref for r#RepAtLeastOnce < 'i > { type Target = super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#RepAtLeastOnce < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#RepAtLeastOnce < 'i > { const RULE : super :: Rule = super :: Rule :: r#RepAtLeastOnce ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#RepAtLeastOnce < 'i > { type Inner = super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#RepAtLeastOnce < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: RepOnce :: < 'i , super :: generics :: CharRange :: < 'i , '0' , '9' > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#RepAtLeastOnce < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#RepAtLeastOnce < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("RepAtLeastOnce") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#RepAtLeastOnce < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#RepAtLeastOnce < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#RepAtLeastOnce < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `\"?\"?`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Opt < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_18 > > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Opt < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Opt < 'i > { type Target = super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_18 > > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Opt < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Opt < 'i > { const RULE : super :: Rule = super :: Rule :: r#Opt ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Opt < 'i > { type Inner = super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_18 > > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Opt < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_18 > > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Opt < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Opt < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Opt") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Opt < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Opt < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Opt < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"a\" ~ \"a\" ~ \"a\")`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepExact < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_19 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_20 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_21 > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#RepExact < 'i > { } impl < 'i > :: core :: ops :: Deref for r#RepExact < 'i > { type Target = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_19 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_20 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_21 > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#RepExact < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#RepExact < 'i > { const RULE : super :: Rule = super :: Rule :: r#RepExact ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#RepExact < 'i > { type Inner = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_19 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_20 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_21 > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#RepExact < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_3 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_19 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_20 > , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_21 > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#RepExact < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#RepExact < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("RepExact") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#RepExact < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#RepExact < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#RepExact < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"0\" ~ \"0\"*)`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepLeft < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_22 > , super :: generics :: Rep :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_23 > , > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#RepLeft < 'i > { } impl < 'i > :: core :: ops :: Deref for r#RepLeft < 'i > { type Target = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_22 > , super :: generics :: Rep :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_23 > , > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#RepLeft < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#RepLeft < 'i > { const RULE : super :: Rule = super :: Rule :: r#RepLeft ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#RepLeft < 'i > { type Inner = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_22 > , super :: generics :: Rep :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_23 > , > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#RepLeft < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_22 > , super :: generics :: Rep :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_23 > , > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#RepLeft < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#RepLeft < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("RepLeft") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#RepLeft < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#RepLeft < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#RepLeft < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"1\"? ~ \"1\"?)`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepRight < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_2 :: < 'i , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_24 > > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_25 > > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#RepRight < 'i > { } impl < 'i > :: core :: ops :: Deref for r#RepRight < 'i > { type Target = super :: generics :: Seq_2 :: < 'i , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_24 > > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_25 > > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#RepRight < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#RepRight < 'i > { const RULE : super :: Rule = super :: Rule :: r#RepRight ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#RepRight < 'i > { type Inner = super :: generics :: Seq_2 :: < 'i , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_24 > > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_25 > > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#RepRight < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_2 :: < 'i , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_24 > > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_25 > > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#RepRight < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#RepRight < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("RepRight") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#RepRight < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#RepRight < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#RepRight < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `(\"2\" ~ \"2\"?)`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#RepLeftRight < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_26 > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_27 > > , > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#RepLeftRight < 'i > { } impl < 'i > :: core :: ops :: Deref for r#RepLeftRight < 'i > { type Target = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_26 > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_27 > > , > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#RepLeftRight < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#RepLeftRight < 'i > { const RULE : super :: Rule = super :: Rule :: r#RepLeftRight ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#RepLeftRight < 'i > { type Inner = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_26 > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_27 > > , > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#RepLeftRight < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Seq_2 :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_26 > , super :: generics :: Opt :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_27 > > , > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#RepLeftRight < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#RepLeftRight < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("RepLeftRight") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#RepLeftRight < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#RepLeftRight < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#RepLeftRight < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `SOI`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Pos < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Positive :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#SOI :: < 'i >> > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Pos < 'i > { # [doc = "A helper function to access [`SOI`]."] # [allow (non_snake_case)] pub fn r#SOI < 's > (& 's self) -> & 's super :: pairs :: r#SOI :: < 'i > { let res = & self . content ; { let res = & res . content ; { let res = res . content . deref () ; res } } } } impl < 'i > :: core :: ops :: Deref for r#Pos < 'i > { type Target = super :: generics :: Positive :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#SOI :: < 'i >> > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Pos < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Pos < 'i > { const RULE : super :: Rule = super :: Rule :: r#Pos ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Pos < 'i > { type Inner = super :: generics :: Positive :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#SOI :: < 'i >> > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Pos < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Positive :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#SOI :: < 'i >> > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Pos < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Pos < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Pos") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Pos < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Pos < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Pos < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `EOI`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Neg < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Negative :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#EOI :: < 'i >> > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Neg < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Neg < 'i > { type Target = super :: generics :: Negative :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#EOI :: < 'i >> > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Neg < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Neg < 'i > { const RULE : super :: Rule = super :: Rule :: r#Neg ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Neg < 'i > { type Inner = super :: generics :: Negative :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#EOI :: < 'i >> > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Neg < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Negative :: < 'i , super :: generics :: Box :: < 'i , super :: pairs :: r#EOI :: < 'i >> > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Neg < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Neg < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Neg") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Neg < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Neg < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Neg < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `\" \"`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Push < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Push :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_28 > > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Push < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Push < 'i > { type Target = super :: generics :: Push :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_28 > > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Push < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Push < 'i > { const RULE : super :: Rule = super :: Rule :: r#Push ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Push < 'i > { type Inner = super :: generics :: Push :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_28 > > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Push < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Push :: < 'i , super :: generics :: Str :: < 'i , super :: constant_wrappers :: r#w_28 > > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Push < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Push < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Push") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Push < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Push < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Push < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `POP`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Pop < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Box :: < 'i , super :: pairs :: r#POP :: < 'i >> , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Pop < 'i > { # [doc = "A helper function to access [`POP`]."] # [allow (non_snake_case)] pub fn r#POP < 's > (& 's self) -> & 's super :: pairs :: r#POP :: < 'i > { let res = & self . content ; { let res = res . content . deref () ; res } } } impl < 'i > :: core :: ops :: Deref for r#Pop < 'i > { type Target = super :: generics :: Box :: < 'i , super :: pairs :: r#POP :: < 'i >> ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Pop < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Pop < 'i > { const RULE : super :: Rule = super :: Rule :: r#Pop ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Pop < 'i > { type Inner = super :: generics :: Box :: < 'i , super :: pairs :: r#POP :: < 'i >> ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Pop < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Box :: < 'i , super :: pairs :: r#POP :: < 'i >> :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Pop < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Pop < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Pop") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Pop < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Pop < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Pop < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `POP_ALL`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PopAll < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Box :: < 'i , super :: pairs :: r#POP_ALL :: < 'i >> , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#PopAll < 'i > { # [doc = "A helper function to access [`POP_ALL`]."] # [allow (non_snake_case)] pub fn r#POP_ALL < 's > (& 's self) -> & 's super :: pairs :: r#POP_ALL :: < 'i > { let res = & self . content ; { let res = res . content . deref () ; res } } } impl < 'i > :: core :: ops :: Deref for r#PopAll < 'i > { type Target = super :: generics :: Box :: < 'i , super :: pairs :: r#POP_ALL :: < 'i >> ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#PopAll < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#PopAll < 'i > { const RULE : super :: Rule = super :: Rule :: r#PopAll ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#PopAll < 'i > { type Inner = super :: generics :: Box :: < 'i , super :: pairs :: r#POP_ALL :: < 'i >> ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#PopAll < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Box :: < 'i , super :: pairs :: r#POP_ALL :: < 'i >> :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#PopAll < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#PopAll < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("PopAll") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#PopAll < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#PopAll < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#PopAll < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `PEEK[0..]`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Peek < 'i > { # [doc = "Matched content."] pub content : super :: generics :: PeekSlice1 :: < 'i , 0i32 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Peek < 'i > { } impl < 'i > :: core :: ops :: Deref for r#Peek < 'i > { type Target = super :: generics :: PeekSlice1 :: < 'i , 0i32 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Peek < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Peek < 'i > { const RULE : super :: Rule = super :: Rule :: r#Peek ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Peek < 'i > { type Inner = super :: generics :: PeekSlice1 :: < 'i , 0i32 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Peek < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: PeekSlice1 :: < 'i , 0i32 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Peek < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Peek < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Peek") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Peek < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Peek < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Peek < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `PEEK[1..]`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekLeft < 'i > { # [doc = "Matched content."] pub content : super :: generics :: PeekSlice1 :: < 'i , 1i32 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#PeekLeft < 'i > { } impl < 'i > :: core :: ops :: Deref for r#PeekLeft < 'i > { type Target = super :: generics :: PeekSlice1 :: < 'i , 1i32 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#PeekLeft < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekLeft < 'i > { const RULE : super :: Rule = super :: Rule :: r#PeekLeft ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#PeekLeft < 'i > { type Inner = super :: generics :: PeekSlice1 :: < 'i , 1i32 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#PeekLeft < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: PeekSlice1 :: < 'i , 1i32 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#PeekLeft < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#PeekLeft < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("PeekLeft") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#PeekLeft < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#PeekLeft < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#PeekLeft < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `PEEK[0..]`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekRight < 'i > { # [doc = "Matched content."] pub content : super :: generics :: PeekSlice1 :: < 'i , 0i32 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#PeekRight < 'i > { } impl < 'i > :: core :: ops :: Deref for r#PeekRight < 'i > { type Target = super :: generics :: PeekSlice1 :: < 'i , 0i32 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#PeekRight < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekRight < 'i > { const RULE : super :: Rule = super :: Rule :: r#PeekRight ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#PeekRight < 'i > { type Inner = super :: generics :: PeekSlice1 :: < 'i , 0i32 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#PeekRight < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: PeekSlice1 :: < 'i , 0i32 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#PeekRight < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#PeekRight < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("PeekRight") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#PeekRight < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#PeekRight < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#PeekRight < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `PEEK[1..2]`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekLeftRight < 'i > { # [doc = "Matched content."] pub content : super :: generics :: PeekSlice2 :: < 'i , 1i32 , 2i32 > , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#PeekLeftRight < 'i > { } impl < 'i > :: core :: ops :: Deref for r#PeekLeftRight < 'i > { type Target = super :: generics :: PeekSlice2 :: < 'i , 1i32 , 2i32 > ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#PeekLeftRight < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekLeftRight < 'i > { const RULE : super :: Rule = super :: Rule :: r#PeekLeftRight ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#PeekLeftRight < 'i > { type Inner = super :: generics :: PeekSlice2 :: < 'i , 1i32 , 2i32 > ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#PeekLeftRight < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: PeekSlice2 :: < 'i , 1i32 , 2i32 > :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#PeekLeftRight < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#PeekLeftRight < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("PeekLeftRight") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#PeekLeftRight < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#PeekLeftRight < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#PeekLeftRight < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `DROP`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#Drop < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Box :: < 'i , super :: pairs :: r#DROP :: < 'i >> , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#Drop < 'i > { # [doc = "A helper function to access [`DROP`]."] # [allow (non_snake_case)] pub fn r#DROP < 's > (& 's self) -> & 's super :: pairs :: r#DROP :: < 'i > { let res = & self . content ; { let res = res . content . deref () ; res } } } impl < 'i > :: core :: ops :: Deref for r#Drop < 'i > { type Target = super :: generics :: Box :: < 'i , super :: pairs :: r#DROP :: < 'i >> ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#Drop < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#Drop < 'i > { const RULE : super :: Rule = super :: Rule :: r#Drop ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#Drop < 'i > { type Inner = super :: generics :: Box :: < 'i , super :: pairs :: r#DROP :: < 'i >> ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#Drop < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Box :: < 'i , super :: pairs :: r#DROP :: < 'i >> :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#Drop < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#Drop < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("Drop") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#Drop < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#Drop < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#Drop < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } # [doc = "Corresponds to expression: `PEEK_ALL`."] # [doc = "Normal rule."] # [allow (non_camel_case_types)] # [derive (Clone , PartialEq)] pub struct r#PeekAll < 'i > { # [doc = "Matched content."] pub content : super :: generics :: Box :: < 'i , super :: pairs :: r#PEEK_ALL :: < 'i >> , # [doc = "Matched span."] pub span : :: pest_typed :: Span < 'i > , } impl < 'i > r#PeekAll < 'i > { # [doc = "A helper function to access [`PEEK_ALL`]."] # [allow (non_snake_case)] pub fn r#PEEK_ALL < 's > (& 's self) -> & 's super :: pairs :: r#PEEK_ALL :: < 'i > { let res = & self . content ; { let res = res . content . deref () ; res } } } impl < 'i > :: core :: ops :: Deref for r#PeekAll < 'i > { type Target = super :: generics :: Box :: < 'i , super :: pairs :: r#PEEK_ALL :: < 'i >> ; fn deref (& self) -> & Self :: Target { & self . content } } impl < 'i > :: core :: ops :: DerefMut for r#PeekAll < 'i > { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . content } } impl < 'i > :: pest_typed :: RuleWrapper < super :: Rule > for r#PeekAll < 'i > { const RULE : super :: Rule = super :: Rule :: r#PeekAll ; type Rule = super :: Rule ; } impl < 'i > :: pest_typed :: TypeWrapper for r#PeekAll < 'i > { type Inner = super :: generics :: Box :: < 'i , super :: pairs :: r#PEEK_ALL :: < 'i >> ; } impl < 'i > :: pest_typed :: TypedNode < 'i , super :: Rule > for r#PeekAll < 'i > { # [inline] fn try_parse_with < const ATOMIC : :: core :: primitive :: bool > (input : :: pest_typed :: Position < 'i > , stack : & mut :: pest_typed :: Stack < :: pest_typed :: Span < 'i >> , tracker : & mut :: pest_typed :: tracker :: Tracker < 'i , super :: Rule > ,) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , () > { let start = input ; tracker . record_during (input , | tracker | { let (input , content) = super :: generics :: Box :: < 'i , super :: pairs :: r#PEEK_ALL :: < 'i >> :: try_parse_with :: < ATOMIC > (input , stack , tracker) ? ; let span = start . span (& input) ; Ok ((input , Self { content , span })) }) } } impl < 'i > :: pest_typed :: ParsableTypedNode < 'i , super :: Rule > for r#PeekAll < 'i > { # [inline] fn parse (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < Self , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; let (input , res) = match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; let (input , _) = super :: generics :: Ignored :: < 'i > :: parse_with :: < false > (input , & mut stack) ; let (_ , _) = match super :: pairs :: EOI :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => (input , res) , Err (_) => return Err (tracker . collect ()) , } ; Ok (res) } # [inline] fn parse_partial (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < (:: pest_typed :: Position < 'i > , Self) , :: pest_typed :: error :: Error < super :: Rule >> { let mut stack = :: pest_typed :: Stack :: new () ; let input = :: pest_typed :: Position :: from_start (input) ; let mut tracker = :: pest_typed :: tracker :: Tracker :: new (input) ; match Self :: try_parse_with :: < false > (input , & mut stack , & mut tracker) { Ok ((input , res)) => Ok ((input , res)) , Err (_) => return Err (tracker . collect ()) , } } } impl < 'i > :: core :: fmt :: Debug for r#PeekAll < 'i > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { f . debug_struct ("PeekAll") . field ("content" , & self . content) . field ("span" , & self . span) . finish () } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pairs < 'i , 'n , super :: Rule > for r#PeekAll < 'i > { type Iter = :: core :: iter :: Once < & 'n dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >> ; type IntoIter = :: core :: iter :: Once < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> ; fn iter (& 'n self) -> Self :: Iter { :: core :: iter :: once (self) } fn into_iter (self) -> Self :: IntoIter { :: core :: iter :: once (:: pest_typed :: re_exported :: Box :: new (self)) } } impl < 'i : 'n , 'n > :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > for r#PeekAll < 'i > { fn inner (& 'n self) -> :: pest_typed :: re_exported :: vec :: IntoIter < & 'n (dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule >) > { self . content . iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } fn into_inner (self) -> :: pest_typed :: re_exported :: vec :: IntoIter < :: pest_typed :: re_exported :: Box < dyn :: pest_typed :: iterators :: Pair < 'i , 'n , super :: Rule > + 'n >> { self . content . into_iter () . collect :: < :: pest_typed :: re_exported :: Vec :: < _ >> () . into_iter () } } impl < 'i > :: pest_typed :: RuleStruct < 'i , super :: Rule > for r#PeekAll < 'i > { fn span (& self) -> :: pest_typed :: Span < 'i > { self . span } } use :: pest_typed :: NeverFailedTypedNode as _ ; use :: pest_typed :: TypedNode as _ ; use :: core :: ops :: Deref as _ ; use super :: unicode :: * ; # [allow (non_camel_case_types)] pub type EOI < 'i > = :: pest_typed :: predefined_node :: AtomicRule :: < 'i , super :: Rule , :: pest_typed :: predefined_node :: EOI :: < 'i > , super :: rule_wrappers :: EOI , super :: rule_wrappers :: EOI > ; # [allow (non_camel_case_types)] pub type r#ANY < 'i > = :: pest_typed :: predefined_node :: ANY <'i > ; # [allow (non_camel_case_types)] pub type r#SOI < 'i > = :: pest_typed :: predefined_node :: SOI <'i > ; # [allow (non_camel_case_types)] pub type r#PEEK < 'i > = :: pest_typed :: predefined_node :: PEEK <'i > ; # [allow (non_camel_case_types)] pub type r#PEEK_ALL < 'i > = :: pest_typed :: predefined_node :: PEEK_ALL <'i > ; # [allow (non_camel_case_types)] pub type r#POP < 'i > = :: pest_typed :: predefined_node :: POP <'i > ; # [allow (non_camel_case_types)] pub type r#POP_ALL < 'i > = :: pest_typed :: predefined_node :: POP_ALL <'i > ; # [allow (non_camel_case_types)] pub type r#DROP < 'i > = :: pest_typed :: predefined_node :: DROP <'i > ; # [allow (non_camel_case_types)] pub type r#ASCII_DIGIT < 'i > = :: pest_typed :: predefined_node :: ASCII_DIGIT <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_NONZERO_DIGIT < 'i > = :: pest_typed :: predefined_node :: ASCII_NONZERO_DIGIT <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_BIN_DIGIT < 'i > = :: pest_typed :: predefined_node :: ASCII_BIN_DIGIT <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_OCT_DIGIT < 'i > = :: pest_typed :: predefined_node :: ASCII_OCT_DIGIT <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_HEX_DIGIT < 'i > = :: pest_typed :: predefined_node :: ASCII_HEX_DIGIT <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_ALPHA_LOWER < 'i > = :: pest_typed :: predefined_node :: ASCII_ALPHA_LOWER <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_ALPHA_UPPER < 'i > = :: pest_typed :: predefined_node :: ASCII_ALPHA_UPPER <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_ALPHA < 'i > = :: pest_typed :: predefined_node :: ASCII_ALPHA <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII_ALPHANUMERIC < 'i > = :: pest_typed :: predefined_node :: ASCII_ALPHANUMERIC <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#ASCII < 'i > = :: pest_typed :: predefined_node :: ASCII <'i , super :: Rule > ; # [allow (non_camel_case_types)] pub type r#NEWLINE < 'i > = :: pest_typed :: predefined_node :: NEWLINE <'i > ; # [allow (non_camel_case_types)] pub type r#WHITESPACE < 'i > = :: pest_typed :: predefined_node :: AlwaysFail <'i > ; # [allow (non_camel_case_types)] pub type r#COMMENT < 'i > = :: pest_typed :: predefined_node :: AlwaysFail <'i > ; } # [doc (hidden)] mod generics { use :: pest_typed as pest_typed ; use :: pest_typed :: { NeverFailedTypedNode , predefined_node , StringArrayWrapper , StringWrapper , TypedNode } ; pub type Ignored < 'i > = predefined_node :: Ign :: < 'i , super :: Rule , super :: pairs :: COMMENT :: < 'i > , super :: pairs :: WHITESPACE :: < 'i > , > ; pub type Str < 'i , Wrapper : StringWrapper > = predefined_node :: Str :: < 'i , super :: Rule , Wrapper > ; pub type Insens < 'i , Wrapper : StringWrapper > = predefined_node :: Insens :: < 'i , super :: Rule , Wrapper > ; pub type PeekSlice2 < 'i , const START : :: core :: primitive :: i32 , const END : :: core :: primitive :: i32 > = predefined_node :: PeekSlice2 :: < 'i , super :: Rule , START , END > ; pub type PeekSlice1 < 'i , const START : :: core :: primitive :: i32 > = predefined_node :: PeekSlice1 :: < 'i , super :: Rule , START > ; pub type Push < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Push < 'i , super :: Rule , T > ; pub type Skip < 'i , Strings : StringArrayWrapper > = predefined_node :: Skip :: < 'i , super :: Rule , Strings > ; pub type CharRange < 'i , const START : :: core :: primitive :: char , const END : :: core :: primitive :: char > = predefined_node :: CharRange :: < 'i , super :: Rule , START , END > ; pub type Box < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Box < 'i , super :: Rule , T > ; pub type Positive < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Positive < 'i , super :: Rule , T > ; pub type Negative < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Negative < 'i , super :: Rule , T > ; pub type Restorable < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Restorable < 'i , super :: Rule , T > ; use pest_typed :: sequence :: Seq2 ; pub type Seq_2 < 'i , T0 : TypedNode < 'i , super :: Rule > , T1 : TypedNode < 'i , super :: Rule > , > = Seq2 < 'i , super :: Rule , T0 , T1 , Ignored < 'i > , > ; use pest_typed :: sequence :: Seq3 ; pub type Seq_3 < 'i , T0 : TypedNode < 'i , super :: Rule > , T1 : TypedNode < 'i , super :: Rule > , T2 : TypedNode < 'i , super :: Rule > , > = Seq3 < 'i , super :: Rule , T0 , T1 , T2 , Ignored < 'i > , > ; use pest_typed :: choices :: Choice2 ; pub type Choice_2 < 'i , T0 : TypedNode < 'i , super :: Rule > , T1 : TypedNode < 'i , super :: Rule > , > = Choice2 < 'i , super :: Rule , T0 , T1 , > ; use pest_typed :: choices :: Choice3 ; pub type Choice_3 < 'i , T0 : TypedNode < 'i , super :: Rule > , T1 : TypedNode < 'i , super :: Rule > , T2 : TypedNode < 'i , super :: Rule > , > = Choice3 < 'i , super :: Rule , T0 , T1 , T2 , > ; pub type Opt < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Opt < 'i , super :: Rule , T > ; pub type Rep < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: Rep < 'i , super :: Rule , T , Ignored < 'i >> ; pub type RepOnce < 'i , T : TypedNode < 'i , super :: Rule >> = predefined_node :: RepOnce < 'i , super :: Rule , T , Ignored < 'i >> ; } # [allow (clippy :: all)] impl :: pest_typed :: TypedParser < Rule > for Parser { fn parse < 'i , T : :: pest_typed :: ParsableTypedNode < 'i , Rule >> (input : & 'i :: core :: primitive :: str) -> :: pest_typed :: re_exported :: Result < T , :: pest_typed :: error :: Error < Rule > > { T :: parse (input) } }